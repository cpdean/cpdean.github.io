<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Write Set Coverage in Hypothesis</title>
  <meta name="description" content="Coming up with properties is hard.">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://blog.conradpdean.com/2016/07/24/set-coverage-hypothesis.html">
  <link rel="alternate" type="application/rss+xml" title="Conrad Dean" href="http://blog.conradpdean.com/feed.xml">

  
  <!--Google Analytics-->
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-23627863-2', 'auto');
    ga('send', 'pageview');
  </script>
  <!--/Google Analytics-->
  
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Conrad Dean</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Write Set Coverage in Hypothesis</h1>
    <p class="post-meta"><time datetime="2016-07-24T11:40:09-04:00" itemprop="datePublished">Jul 24, 2016</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Coming up with properties is hard.</p>

<p>For example, say you want to implement set coverage.  Write a function that
takes a list of sets, and returns the smallest list of these sets, where every
element in the large set is now in the small set.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">large_set_of_sets</span> <span class="o">=</span> <span class="p">[{</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">}]</span>
<span class="n">reduce_sets</span><span class="p">(</span><span class="n">large_set_of_sets</span><span class="p">)</span>  <span class="c1"># [{1, 2}]
</span></code></pre></div></div>

<p>We’re going to walk through how to implement properties that test set coverage.
Once we’ve written properties that give boundaried so it’s behavior, hypothesis
will discover bugs in how we’ve written our code and give us concrete examples
of bugs to fix.</p>

<h2 id="what-are-our-properties">What are our properties?</h2>

<p>What are the properties of <code class="language-plaintext highlighter-rouge">reduce_sets</code> ?  If you want to steal from Discrete
Math or CS, here are a couple:</p>

<ol>
  <li>The number of sets in the output is the same or less than the number of sets from the input.</li>
  <li>Every number in the list of input sets is in the list of output sets.</li>
  <li>Every set of numbers in the output list was also in the input list.</li>
  <li>There are no duplicate sets in the output.</li>
  <li>No output set is a subset of any other output set</li>
  <li>No output set is a subset of the other sets combined.</li>
  <li>The output set is the smallest possible number of sets with the previous properties still satisfied.</li>
</ol>

<p>(I got most of these from <a href="http://blog.jessitron.com/2013/04/property-based-testing-what-is-it.html">Jessica Kerr</a>)</p>

<p>The last property is particularly hard, for example the following two solutions
are valid on all the properties but the last property:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">large_set_of_sets</span> <span class="o">=</span> <span class="p">[{</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">}]</span>
<span class="n">reduce_sets</span><span class="p">(</span><span class="n">large_set_of_sets</span><span class="p">)</span>  <span class="c1"># [{1}, {2}] -- covers all the elements
</span><span class="n">reduce_sets</span><span class="p">(</span><span class="n">large_set_of_sets</span><span class="p">)</span>  <span class="c1"># [{1, 2}]   -- but this is smaller
</span></code></pre></div></div>

<p>But we’ll get to why it’s <a href="https://en.wikipedia.org/wiki/NP-hardness">hard</a> at the end.</p>

<p>Let’s work through how we’d implement these properties.</p>

<h2 id="a-unit-test">A Unit Test</h2>

<p>We’ll be using <a href="http://hypothesis.readthedocs.io/en/latest/quickstart.html">hypothesis</a> with <a href="http://pytest.org/latest/">pytest</a>.</p>

<p>Let’s turn our first example of how set coverage works into a unit test on its
own.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">setcoverage</span> <span class="kn">import</span> <span class="n">reduce_sets</span>

<span class="k">def</span> <span class="nf">test_example</span><span class="p">():</span>
    <span class="n">s</span> <span class="o">=</span> <span class="p">[{</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">}]</span>
    <span class="k">assert</span> <span class="n">reduce_sets</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="p">[{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}]</span>
</code></pre></div></div>

<p>And here’s the minimum amount of code it takes to make the test pass:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">reduce_sets</span><span class="p">(</span><span class="n">sets</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}]</span>
</code></pre></div></div>

<p>Look! Set Coverage in one line!  Running the tests proves our success and genius:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ tox -e py27
GLOB sdist-make: /Users/conrad/dev/set-coverage-example/setup.py
py27 inst-nodeps: /Users/conrad/dev/set-coverage-example/.tox/dist/setcoverage-0.0.1.zip
py27 installed: enum34==1.1.6,hypothesis==3.4.1,py==1.4.31,pytest==2.9.2,setcoverage==0.0.1,wheel==0.24.0
py27 runtests: PYTHONHASHSEED='4047888479'
py27 runtests: commands[0] | py.test
======================= test session starts =======================
platform darwin -- Python 2.7.10, pytest-2.9.2, py-1.4.31, pluggy-0.3.1
rootdir: /Users/conrad/dev/set-coverage-example, inifile:
plugins: hypothesis-3.4.1
collected 1 items

tests/test_thing.py .

==================== 1 passed in 0.01 seconds =====================
_____________________________ summary _____________________________
  py27: commands succeeded
  congratulations :)
</code></pre></div></div>

<h2 id="our-first-property-the-cardinality-constraint">Our First Property: The Cardinality Constraint</h2>

<p>The first property we’re going to implement on our set coverage code is this:
The output list of sets should have the same number of sets or fewer a number
of sets than the input list of sets.</p>

<p>We know this has to be a property of a function that solves set coverage
because if it didn’t have this property, that would mean it sometimes returns
<strong>more</strong> sets than it was given.  That goes against the premise of what it does
– finding the smallest number of sets.</p>

<p>Here’s what that property looks like in python:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">hypothesis</span> <span class="k">as</span> <span class="n">h</span>
<span class="kn">from</span> <span class="nn">hypothesis</span> <span class="kn">import</span> <span class="n">strategies</span> <span class="k">as</span> <span class="n">st</span>

<span class="c1"># ...
</span>
<span class="o">@</span><span class="n">h</span><span class="p">.</span><span class="n">given</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">lists</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">sets</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">integers</span><span class="p">())))</span>
<span class="k">def</span> <span class="nf">test_that_output_has_fewer_sets_than_input</span><span class="p">(</span><span class="n">sets</span><span class="p">):</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">reduce_sets</span><span class="p">(</span><span class="n">sets</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sets</span><span class="p">)</span>
</code></pre></div></div>

<p>Now we’ll let hypothesis find us a failing test case by just re-running our
test suite.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
======================= test session starts =======================
platform darwin -- Python 2.7.10, pytest-2.9.2, py-1.4.31, pluggy-0.3.1
rootdir: /Users/conrad/dev/set-coverage-example, inifile:
plugins: hypothesis-3.4.1
collected 2 items

tests/test_thing.py .F

============================ FAILURES =============================
___________ test_that_output_has_fewer_sets_than_input ____________

    @h.given(st.lists(st.sets(st.integers())))
&gt;   def test_that_output_has_fewer_sets_than_input(sets):

tests/test_thing.py:13:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.tox/py27/lib/python2.7/site-packages/hypothesis/core.py:520: in wrapped_test
    print_example=True, is_final=True
.tox/py27/lib/python2.7/site-packages/hypothesis/executors.py:58: in default_new_style_executor
    return function(data)
.tox/py27/lib/python2.7/site-packages/hypothesis/core.py:110: in run
    return test(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

sets = []

    @h.given(st.lists(st.sets(st.integers())))
    def test_that_output_has_fewer_sets_than_input(sets):
        output = reduce_sets(sets)
&gt;       assert len(output) &lt;= len(sets)
E       assert 1 &lt;= 0
E        +  where 1 = len([set([1, 2])])
E        +  and   0 = len([])

tests/test_thing.py:15: AssertionError
--------------------------- Hypothesis ----------------------------
Falsifying example: test_that_output_has_fewer_sets_than_input(sets=[])
=============== 1 failed, 1 passed in 0.10 seconds ================
ERROR: InvocationError: '/Users/conrad/dev/set-coverage-example/.tox/py27/bin/py.test'
_____________________________ summary _____________________________
ERROR:   py27: commands failed
</code></pre></div></div>

<p>Hypothesis found data which will show our implementation doesn’t satisfy
that property.  Let’s zoom in on the error itself to see what Hypothesis tried.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sets = []

    @h.given(st.lists(st.sets(st.integers())))
    def test_that_output_has_fewer_sets_than_input(sets):
        output = reduce_sets(sets)
&gt;       assert len(output) &lt;= len(sets)
E       assert 1 &lt;= 0
E        +  where 1 = len([set([1, 2])])
E        +  and   0 = len([])

tests/test_thing.py:15: AssertionError
--------------------------- Hypothesis ----------------------------
Falsifying example: test_that_output_has_fewer_sets_than_input(sets=[])
</code></pre></div></div>

<p>At the beginning of the failure test case, we can see the input data clearly
labeled: <code class="language-plaintext highlighter-rouge">sets = []</code>.  This means that Hypothesis tried to run the test with an
empty list.  If we look a bit closer at the assertion that failed we can see
how the property we define interacts with the input data:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;       assert len(output) &lt;= len(sets)
E       assert 1 &lt;= 0
E        +  where 1 = len([set([1, 2])])
E        +  and   0 = len([])
</code></pre></div></div>

<p>This is a <a href="http://pytest.org/latest/assert.html">feature of pytest</a> that extends Python’s built-in
assertion statement to provide useful debug information.  It’s showing us how
the empty list has zero elements, where our function is still returning data to
solve its own use-case.</p>

<p>Let’s return to our implementation and write the minimum amount of code to pass both the test case and this property:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">reduce_sets</span><span class="p">(</span><span class="n">sets</span><span class="p">):</span>
    <span class="c1"># remove first and last item
</span>    <span class="k">return</span> <span class="n">sets</span><span class="p">[</span><span class="mi">1</span><span class="p">:][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>It just so happens that slice syntax will return empty lists if you over-slice
and on our test case the input only needs the first and last items pruned to
pass.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>======================= test session starts =======================
platform darwin -- Python 2.7.10, pytest-2.9.2, py-1.4.31, pluggy-0.3.1
rootdir: /Users/conrad/dev/set-coverage-example, inifile:
plugins: hypothesis-3.4.1
collected 2 items

tests/test_thing.py ..

==================== 2 passed in 0.31 seconds =====================
_____________________________ summary _____________________________
  py27: commands succeeded
  congratulations :)
</code></pre></div></div>

<h1 id="property-two-all-elements-in-the-sets-are-in-the-output-from-the-input">Property Two: All elements in the Sets are in the Output from the Input</h1>

<p>The next property of a function that does set coverage is that no items are lost
in the output list.  To implement this property, we’ll just say that the
set of all items coming in are the same as the set of all items coming out.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>

<span class="c1"># ...
</span>
<span class="o">@</span><span class="n">h</span><span class="p">.</span><span class="n">given</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">lists</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">sets</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">integers</span><span class="p">())))</span>
<span class="k">def</span> <span class="nf">test_no_items_lost</span><span class="p">(</span><span class="n">sets</span><span class="p">):</span>
    <span class="n">union</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span><span class="p">.</span><span class="n">union</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">all_input</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">union</span><span class="p">,</span> <span class="n">sets</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
    <span class="n">all_output</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">union</span><span class="p">,</span> <span class="n">reduce_sets</span><span class="p">(</span><span class="n">sets</span><span class="p">),</span> <span class="nb">set</span><span class="p">())</span>
    <span class="k">assert</span> <span class="n">all_input</span> <span class="o">==</span> <span class="n">all_output</span>
</code></pre></div></div>

<p>Easy enough, let’s see what Hypothesis finds:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>======================= test session starts =======================
platform darwin -- Python 2.7.10, pytest-2.9.2, py-1.4.31, pluggy-0.3.1
rootdir: /Users/conrad/dev/set-coverage-example, inifile:
plugins: hypothesis-3.4.1
collected 3 items

tests/test_thing.py ..F

============================ FAILURES =============================
_______________________ test_no_items_lost ________________________

    @h.given(st.lists(st.sets(st.integers())))
&gt;   def test_no_items_lost(sets):

tests/test_thing.py:20:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.tox/py27/lib/python2.7/site-packages/hypothesis/core.py:520: in wrapped_test
    print_example=True, is_final=True
.tox/py27/lib/python2.7/site-packages/hypothesis/executors.py:58: in default_new_style_executor
    return function(data)
.tox/py27/lib/python2.7/site-packages/hypothesis/core.py:110: in run
    return test(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

sets = [set([0])]

    @h.given(st.lists(st.sets(st.integers())))
    def test_no_items_lost(sets):
        union = lambda a, b: a.union(b)
        all_input = reduce(union, sets, set())
        all_output = reduce(union, reduce_sets(sets), set())
&gt;       assert all_input == all_output
E       assert set([0]) == set([])
E         Extra items in the left set:
E         0
E         Use -v to get the full diff

tests/test_thing.py:24: AssertionError
--------------------------- Hypothesis ----------------------------
Falsifying example: test_no_items_lost(sets=[{0}])
</code></pre></div></div>

<p>Looks like our pruning strategy from before is removing valuable sets.  Let’s
come up with a way to satisfy all the properties we’ve written so far:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">reduce_sets</span><span class="p">(</span><span class="n">sets</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">sets</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="k">return</span> <span class="n">sets</span>
    <span class="c1"># create a set of the items found
</span>    <span class="n">o</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sets</span><span class="p">:</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">o</span><span class="p">.</span><span class="n">union</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">o</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="property-three-every-output-set-can-be-found-from-the-list-of-input-sets">Property Three: Every output set can be found from the list of input sets</h2>

<p>This property basically is making sure no novel sets are created from our
function.  We can implement this property like this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">h</span><span class="p">.</span><span class="n">given</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">lists</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">sets</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">integers</span><span class="p">())))</span>
<span class="k">def</span> <span class="nf">test_all_sets_come_from_input</span><span class="p">(</span><span class="n">sets</span><span class="p">):</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">reduce_sets</span><span class="p">(</span><span class="n">sets</span><span class="p">)</span>
    <span class="n">forbidden_sets</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">output</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sets</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">forbidden_sets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
</code></pre></div></div>

<p>By running our tests, we can find a case that this fails on:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sets = [set([0]), set([1])]

    @h.given(st.lists(st.sets(st.integers())))
    def test_all_sets_come_from_input(sets):
        output = reduce_sets(sets)
        forbidden_sets = [s for s in output if s not in sets]
&gt;       assert len(forbidden_sets) == 0
E       assert 1 == 0
E        +  where 1 = len([set([0, 1])])

tests/test_thing.py:31: AssertionError
--------------------------- Hypothesis ----------------------------
Falsifying example: test_all_sets_come_from_input(sets=[{0}, {1}])
</code></pre></div></div>

<p>It’s clear why this is happening since our implementation is strictly creating
a new superset from the sets its given.</p>

<p>Let’s come up with a new way to satisfy all the tests we’ve seen so far:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_without</span><span class="p">(</span><span class="n">objects</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="s">"""
    get a list of objects without
    the element at i
    """</span>
    <span class="k">return</span> <span class="n">objects</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">objects</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>


<span class="k">def</span> <span class="nf">_prune_one</span><span class="p">(</span><span class="n">sets</span><span class="p">):</span>
    <span class="s">""" attempt to remove a single item """</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sets</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">_without</span><span class="p">(</span><span class="n">sets</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_without</span><span class="p">(</span><span class="n">sets</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sets</span>


<span class="k">def</span> <span class="nf">reduce_sets</span><span class="p">(</span><span class="n">sets</span><span class="p">):</span>
    <span class="n">one_removed</span> <span class="o">=</span> <span class="n">_prune_one</span><span class="p">(</span><span class="n">sets</span><span class="p">)</span>
    <span class="n">two_removed</span> <span class="o">=</span> <span class="n">_prune_one</span><span class="p">(</span><span class="n">one_removed</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">two_removed</span>
</code></pre></div></div>

<p>Our implementation just looks for items to safely remove, and removes them. I’m
only doing this twice because I want only want to solve for the properties
we’ve seen so far.</p>

<p>Note:  This implementation will break that first unit test we wrote.  To
prevent this unit test from distracting us, let’s <a href="http://pytest.org/latest/skipping.html#marking-a-test-function-to-be-skipped">mark it for
skipping</a> so that pytest won’t run it.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">pytest</span>

<span class="c1"># ...
</span>

<span class="o">@</span><span class="n">pytest</span><span class="p">.</span><span class="n">mark</span><span class="p">.</span><span class="n">skip</span><span class="p">(</span><span class="n">reason</span><span class="o">=</span><span class="s">'focusing on prop tests for now'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">test_example</span><span class="p">():</span>
    <span class="n">s</span> <span class="o">=</span> <span class="p">[{</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">}]</span>
    <span class="k">assert</span> <span class="n">reduce_sets</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="p">[{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}]</span>
</code></pre></div></div>

<p>When you’re skipping a test, it shows up in the suite progress as the letter ‘s’:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>======================= test session starts =======================
platform darwin -- Python 2.7.10, pytest-2.9.2, py-1.4.31, pluggy-0.3.1
rootdir: /Users/conrad/dev/set-coverage-example, inifile:
plugins: hypothesis-3.4.1
collected 5 items

tests/test_thing.py s....

=============== 4 passed, 1 skipped in 1.12 seconds ===============
_____________________________ summary _____________________________
  py27: commands succeeded
  congratulations :)
</code></pre></div></div>

<h2 id="property-four-there-are-no-duplicate-sets-in-the-output">Property Four: There are no duplicate sets in the output.</h2>

<p>The previous solution removes duplicates, but now let’s write a property to
make sure all duplicates are removed.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">h</span><span class="p">.</span><span class="n">given</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">lists</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">sets</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">integers</span><span class="p">())))</span>
<span class="k">def</span> <span class="nf">test_no_duplicate_sets</span><span class="p">(</span><span class="n">sets</span><span class="p">):</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">reduce_sets</span><span class="p">(</span><span class="n">sets</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">e_ix</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">output</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">s_ix</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">output</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">e_ix</span> <span class="o">==</span> <span class="n">s_ix</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">assert</span> <span class="n">e</span> <span class="o">!=</span> <span class="n">s</span><span class="p">,</span> <span class="s">"duplicate in {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
</code></pre></div></div>

<p>Gives us:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sets = [set([]), set([]), set([]), set([])]

    @h.given(st.lists(st.sets(st.integers())))
    def test_no_duplicate_sets(sets):
        output = reduce_sets(sets)
        for e_ix, e in enumerate(output):
            for s_ix, s in enumerate(output):
                if e_ix == s_ix:
                    continue
&gt;               assert e != s, "duplicate in {}".format(output)
E               AssertionError: duplicate in [set([]), set([])]
E               assert set([]) != set([])

tests/test_thing.py:41: AssertionError
--------------------------- Hypothesis ----------------------------
Falsifying example: test_no_duplicate_sets(sets=[set(), set(), set(), set()])
</code></pre></div></div>

<p>Looks like our code fails for inputs with many duplicate sets, which we can
cover by just running the prune helper we wrote for as many times as there are
sets passed in.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">reduce_sets</span><span class="p">(</span><span class="n">sets</span><span class="p">):</span>
    <span class="n">o</span> <span class="o">=</span> <span class="n">sets</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sets</span><span class="p">)):</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">_prune_one</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">o</span>
</code></pre></div></div>

<h2 id="property-five-no-set-in-the-output-list-is-a-subset-of-any-other-set-in-that-list">Property Five: No set in the output list is a subset of any other set in that list.</h2>

<p>We ultimately want to remove anything we can from the list of sets passed in.
Removing duplicates is a good, but we can do better than that because anything
that is a subset of another set can also be tossed out.  By removing a subset,
we will always have the same number of elements covered in our output.</p>

<p>Let’s write a property to look for sets that are subsets of others in the output.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">h</span><span class="p">.</span><span class="n">given</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">lists</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">sets</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">integers</span><span class="p">())))</span>
<span class="k">def</span> <span class="nf">test_no_subsets</span><span class="p">(</span><span class="n">sets</span><span class="p">):</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">reduce_sets</span><span class="p">(</span><span class="n">sets</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">e_ix</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">output</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">s_ix</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">output</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">e_ix</span> <span class="o">==</span> <span class="n">s_ix</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">e</span><span class="p">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="s">"subset found in {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
</code></pre></div></div>

<p>And Hypothesis tells us:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sets = [set([0]), set([])]

    @h.given(st.lists(st.sets(st.integers())))
    def test_no_subsets(sets):
        output = reduce_sets(sets)
        for e_ix, e in enumerate(output):
            for s_ix, s in enumerate(output):
                if e_ix == s_ix:
                    continue
&gt;               assert not e.issubset(s), "subset found in {}".format(output)
E               AssertionError: subset found in [set([0]), set([])]
E               assert not True
E                +  where True = &lt;built-in method issubset of set object at 0x10cbab3f0&gt;(set([0]))
E                +    where &lt;built-in method issubset of set object at 0x10cbab3f0&gt; = set([]).issubset

tests/test_thing.py:53: AssertionError
--------------------------- Hypothesis ----------------------------
Falsifying example: test_no_subsets(sets=[{0}, set()])
</code></pre></div></div>

<p>We could solve this immediately with a one-line change, but I want to play with
this failure case a bit first.  The empty set are subsets of all other sets, so
let’s write a property especially for that.  Our function should never return
anything with an empty set in it.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">h</span><span class="p">.</span><span class="n">given</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">lists</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">sets</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">integers</span><span class="p">())))</span>
<span class="k">def</span> <span class="nf">test_no_empty_sets</span><span class="p">(</span><span class="n">sets</span><span class="p">):</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">reduce_sets</span><span class="p">(</span><span class="n">sets</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">set</span><span class="p">([])</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">output</span>
</code></pre></div></div>

<p>And to solve for it:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">reduce_sets</span><span class="p">(</span><span class="n">sets</span><span class="p">):</span>
    <span class="n">o</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sets</span> <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">([])]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sets</span><span class="p">)):</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">_prune_one</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">o</span>
</code></pre></div></div>

<p>Now we have a more interesting failure case on our original property:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sets = [set([0]), set([0, 1])]

    @h.given(st.lists(st.sets(st.integers())))
    def test_no_subsets(sets):
        output = reduce_sets(sets)
        for e_ix, e in enumerate(output):
            for s_ix, s in enumerate(output):
                if e_ix == s_ix:
                    continue
&gt;               assert not e.issubset(s), "subset found in {}".format(output)
E               AssertionError: subset found in [set([0]), set([0, 1])]
E               assert not True
E                +  where True = &lt;built-in method issubset of set object at 0x1077de4d8&gt;(set([0, 1]))
E                +    where &lt;built-in method issubset of set object at 0x1077de4d8&gt; = set([0]).issubset

tests/test_thing.py:59: AssertionError
--------------------------- Hypothesis ----------------------------
Falsifying example: test_no_subsets(sets=[{0}, {0, 1}])
</code></pre></div></div>

<p>So we can see that <code class="language-plaintext highlighter-rouge">{0}</code> is sneaking into our output even though element <code class="language-plaintext highlighter-rouge">0</code> is
covered by the set <code class="language-plaintext highlighter-rouge">{0, 1}</code>.  Let’s tweak our pruning function to prune for
elements that can find their superset.  This still satisfies the previous
property because duplicate sets are both supersets and subsets of each other.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_prune_one</span><span class="p">(</span><span class="n">sets</span><span class="p">):</span>
    <span class="s">""" attempt to remove a single item """</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sets</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">_without</span><span class="p">(</span><span class="n">sets</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">.</span><span class="n">issuperset</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>  <span class="c1"># changed from 's == e'
</span>                <span class="k">return</span> <span class="n">_without</span><span class="p">(</span><span class="n">sets</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sets</span>


<span class="k">def</span> <span class="nf">reduce_sets</span><span class="p">(</span><span class="n">sets</span><span class="p">):</span>
    <span class="n">o</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sets</span> <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">([])]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sets</span><span class="p">)):</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">_prune_one</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">o</span>
</code></pre></div></div>

<p>And now running our test suite again:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>======================= test session starts =======================
platform darwin -- Python 2.7.10, pytest-2.9.2, py-1.4.31, pluggy-0.3.1
rootdir: /Users/conrad/dev/set-coverage-example, inifile:
plugins: hypothesis-3.4.1
collected 7 items

tests/test_thing.py s......

=============== 6 passed, 1 skipped in 1.75 seconds ===============
_____________________________ summary _____________________________
</code></pre></div></div>

<p>Success! Everything passes!  We can even lift that <code class="language-plaintext highlighter-rouge">skip</code> mark we added before.</p>

<h2 id="property-six-no-output-set-is-a-subset-of-the-other-sets-combined">Property Six: No output set is a subset of the other sets combined.</h2>

<p>This property is actually just a small extension of the previous one.  Checking
to see if a set has a superset isn’t going far enough.  If our function had
some sort of input data and it returned <code class="language-plaintext highlighter-rouge">[{1, 2}, {3, 4}, {2, 3}]</code> you can tell
that it’s incomplete because the set <code class="language-plaintext highlighter-rouge">{2, 3}</code> can be covered from elements
found in the other two sets.  Even though it isn’t a strict subset of either,
it is redundant and safe-to-prune because all of its contents are found in
other sets.</p>

<p>The implementation of this property looks like this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">h</span><span class="p">.</span><span class="n">given</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">lists</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">sets</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">integers</span><span class="p">(</span><span class="n">min_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_value</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span> <span class="n">max_size</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span> <span class="n">max_size</span><span class="o">=</span><span class="mi">8</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">test_no_sibling_superset_cover_a_set_in_output</span><span class="p">(</span><span class="n">sets</span><span class="p">):</span>
    <span class="n">union</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span><span class="p">.</span><span class="n">union</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">without</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">o</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">o</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">o</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">reduce_sets</span><span class="p">(</span><span class="n">sets</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">output</span><span class="p">):</span>
        <span class="n">siblings_superset</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">union</span><span class="p">,</span> <span class="n">without</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="nb">set</span><span class="p">())</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">siblings_superset</span><span class="p">.</span><span class="n">issuperset</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</code></pre></div></div>

<p>And after multiple trials I finally got it to crash:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sets = [set([0, 2]), set([0, 1]), set([1, 2])]

    @h.given(st.lists(st.sets(st.integers(min_value=-1, max_value=5), max_size=3), max_size=8))
    def test_no_sibling_superset_cover_a_set_in_output(sets):
        union = lambda a, b: a.union(b)
        without = lambda o, i: o[:i] + o[i+1:]
        output = reduce_sets(sets)
        for i, e in enumerate(output):
            siblings_superset = reduce(union, without(output, i), set())
&gt;           assert not siblings_superset.issuperset(e)
E           assert not True
E            +  where True = &lt;built-in method issuperset of set object at 0x1042cd878&gt;(set([0, 2]))
E            +    where &lt;built-in method issuperset of set object at 0x1042cd878&gt; = set([0, 1, 2]).issuperset

tests/test_thing.py:68: AssertionError
--------------------------- Hypothesis ----------------------------
Falsifying example: test_no_sibling_superset_cover_a_set_in_output(sets=[{0, 2}, {0, 1}, {1, 2}])
</code></pre></div></div>

<p>The fix to this error is very similar to the last property we implemented.  We
actually just have to check to make sure a given set is not a subset of all the
other sets combined and it will have the same effect as if we were just
checking the sibling sets individually. Because math.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_union_all</span><span class="p">(</span><span class="n">sets</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span><span class="p">.</span><span class="n">union</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">sets</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">_prune_one</span><span class="p">(</span><span class="n">sets</span><span class="p">):</span>
    <span class="s">""" attempt to remove a single item """</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sets</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">_union_all</span><span class="p">(</span><span class="n">_without</span><span class="p">(</span><span class="n">sets</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">.</span><span class="n">issuperset</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_without</span><span class="p">(</span><span class="n">sets</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sets</span>


<span class="k">def</span> <span class="nf">reduce_sets</span><span class="p">(</span><span class="n">sets</span><span class="p">):</span>
    <span class="n">o</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sets</span> <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">([])]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sets</span><span class="p">)):</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">_prune_one</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">o</span>
</code></pre></div></div>

<p>And there we have it, one step closer to our set coverage.</p>

<h2 id="property-seven-the-output-list-has-the-smallest-possible-number-of-sets">Property Seven: The output list has the smallest possible number of sets</h2>

<p>This property is tricky, or at least tedious.  How do we prove that a list of
sets is the smallest possible number of sets?  To show how our solution is
incomplete, we have to come up with a specific failing test case:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_hard_coverage</span><span class="p">():</span>
    <span class="n">s</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">{</span><span class="mi">1</span><span class="p">,</span>   <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span>   <span class="mi">4</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span>   <span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="mi">4</span><span class="p">}</span>
    <span class="p">]</span>
    <span class="k">assert</span> <span class="n">reduce_sets</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="p">[{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}]</span>
</code></pre></div></div>

<p>Another possible solution could be <code class="language-plaintext highlighter-rouge">[{1}, {2, 3}, {4}]</code>, among others, but no
solution is as small in length as the one in the test.</p>

<p>Running pytest with the <code class="language-plaintext highlighter-rouge">-v</code> flag, we can see a completely different solution
was found.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ tox -e py27 -- -v
...
============================ FAILURES =============================
_______________________ test_hard_coverage ________________________

    def test_hard_coverage():
        s = [
            {1,   2}, {3,   4},
            {1}, {2,   3}, {4}
        ]
&gt;       assert reduce_sets(s) == [{1, 2}, {3, 4}]
E       assert [set([1]), se...3]), set([4])] == [set([1, 2]), set([3, 4])]
E         At index 0 diff: set([1]) != set([1, 2])
E         Left contains more items, first extra item: set([4])
E         Full diff:
E         - [set([1]), set([2, 3]), set([4])]
E         + [set([1, 2]), set([3, 4])]

tests/test_thing.py:75: AssertionError
=============== 1 failed, 8 passed in 2.35 seconds ================
ERROR: InvocationError: '/Users/conrad/dev/set-coverage-example/.tox/py27/bin/py.test -v'
</code></pre></div></div>

<p>Our code greedily converges on the wrong solution.  It finds something that
satisfies all the other properties, but it isn’t the smallest solution
possible.  The reason it fails is that it first considers the two sets <code class="language-plaintext highlighter-rouge">{1, 2}</code>
and <code class="language-plaintext highlighter-rouge">{3, 4}</code> for removal.  Because the last 3 elements have all the elements of
the first two, the two ideal sets get removed.</p>

<p>The only way to find an ideal solution would be to generate all possible
solutions that satisfy the above properties, and then grab the smallest one.
In other words, to implement the checker of this property, you have to
implement set coverage yourself, which is the heart of what defines an
<a href="https://en.wikipedia.org/wiki/Reduction_(complexity)">NP-Complete problem</a>.  If you could implement the solution to this
in polynomial time, you win Computer Science.  Every problem as hard as
this one could be solved by your solution too.</p>

<p>So this is the one property I will not implement with Hypothesis.  It would
have to be a strict reimplementation of the solution, maybe if there were more
than one way to implement it we could validate that the two solutions are
equivalent with <a href="https://en.wikipedia.org/wiki/Heat_death_of_the_universe">enough data</a>, but for now a few pointed unit tests
will have to do.</p>

<p>Here’s a pretty slow implementation of set coverage:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span><span class="p">,</span> <span class="n">chain</span>

<span class="c1"># ...
</span>
<span class="k">def</span> <span class="nf">brute_force_set_coverage</span><span class="p">(</span><span class="n">sets</span><span class="p">):</span>
    <span class="s">"""
    most naiive approach to set coverage.

    Try all solutions
    Filter non-covering solutions
    Choose smallest solution
    """</span>
    <span class="n">o</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sets</span> <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">([])]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">o</span>
    <span class="n">goal_set</span> <span class="o">=</span> <span class="n">_union_all</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
    <span class="n">solution_generators</span> <span class="o">=</span> <span class="p">[</span><span class="n">combinations</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">o</span><span class="p">))]</span>
    <span class="n">all_possible_solutions</span> <span class="o">=</span> <span class="n">chain</span><span class="p">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">solution_generators</span><span class="p">)</span>
    <span class="n">valid_solutions</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">all_possible_solutions</span> <span class="k">if</span> <span class="n">_union_all</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">goal_set</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">valid_solutions</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
</code></pre></div></div>

<p>But before we can swap it out for tests, we have to adjust how our generators
work.  Right now, this version will take a much longer time to find a solution
as the list of sets grows in size, so lets put a hard limit on how big sets get.</p>

<p>First let’s refactor our hypothesis generators to source from the same function:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">list_of_sets</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">st</span><span class="p">.</span><span class="n">lists</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">sets</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">integers</span><span class="p">()))</span>


<span class="o">@</span><span class="n">h</span><span class="p">.</span><span class="n">given</span><span class="p">(</span><span class="n">list_of_sets</span><span class="p">())</span>
<span class="k">def</span> <span class="nf">test_that_output_has_fewer_sets_than_input</span><span class="p">(</span><span class="n">sets</span><span class="p">):</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">brute_force_set_coverage</span><span class="p">(</span><span class="n">sets</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sets</span><span class="p">)</span>


<span class="o">@</span><span class="n">h</span><span class="p">.</span><span class="n">given</span><span class="p">(</span><span class="n">list_of_sets</span><span class="p">())</span>
<span class="k">def</span> <span class="nf">test_no_items_lost</span><span class="p">(</span><span class="n">sets</span><span class="p">):</span>
    <span class="n">union</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span><span class="p">.</span><span class="n">union</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">all_input</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">union</span><span class="p">,</span> <span class="n">sets</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
    <span class="n">all_output</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">union</span><span class="p">,</span> <span class="n">brute_force_set_coverage</span><span class="p">(</span><span class="n">sets</span><span class="p">),</span> <span class="nb">set</span><span class="p">())</span>
    <span class="k">assert</span> <span class="n">all_input</span> <span class="o">==</span> <span class="n">all_output</span>

</code></pre></div></div>

<p>And then put some limitations on the size of the lists and sets that get
generated by this generator.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">list_of_sets</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">st</span><span class="p">.</span><span class="n">lists</span><span class="p">(</span>
        <span class="n">st</span><span class="p">.</span><span class="n">sets</span><span class="p">(</span>
            <span class="n">st</span><span class="p">.</span><span class="n">integers</span><span class="p">(</span><span class="n">max_value</span><span class="o">=</span><span class="mi">8</span><span class="p">),</span>
            <span class="n">max_size</span><span class="o">=</span><span class="mi">8</span>
        <span class="p">),</span>
        <span class="n">max_size</span><span class="o">=</span><span class="mi">16</span>
    <span class="p">)</span>
</code></pre></div></div>

<p>Even by limiting it to these small numbers, the entire test suite can take
several seconds longer than it was before:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>======================= test session starts =======================
platform darwin -- Python 2.7.10, pytest-2.9.2, py-1.4.31, pluggy-0.3.1
rootdir: /Users/conrad/dev/set-coverage-example, inifile:
plugins: hypothesis-3.4.1
collected 9 items

tests/test_thing.py .........

==================== 9 passed in 8.99 seconds =====================
_____________________________ summary _____________________________
  py27: commands succeeded
  congratulations :)
</code></pre></div></div>

<p>To view all the code from this post, you can find it on <a href="https://github.com/cpdean/set-coverage-example">Github</a>.</p>


  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Conrad Dean</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <p>Software Engineer in New York City
</p>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
              <! -- hack to make links line up -->
              <a href="https://www.linkedin.com/in/cpdean"><span class="icon icon--twitter" style="display:inline-block; width:20px;"></span><span class="username">LinkedIn</span></a>
          </li>
          
          
          <li>
            <a href="https://github.com/cpdean"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">cpdean</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/deanc"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">deanc</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
